from turbo_utils.threading_control import InterruptibleThread, _run_interruptible_thread
from turbo_utils.threading_control.thread_exceptions import *
from remote_control.scheduler.scheduling import Schedule
from logging import Logger
import threading
from pathlib import Path

"""! Module for the AlertHandler class
"""

# Set up the path for notices to be stored
try:
    data_path = Path("/mnt/14tb_turbo_disk/event_notifications")
    data_path.mkdir(parents=False, exist_ok=True)
except FileNotFoundError:
    data_path = Path(__file__).parent.absolute()

class AlertHandler:
    """! Abstract AlertHandler class. Listens for alerts and then handles them using the provided handler
    """
    def __init__(self, event: threading.Event, buffer: Schedule, logger: Logger):
        """! Constructor for an AlertHandler
        """

        ## @var listening_thread
        #   The thread for listening
        self.listening_thread = None

        ## @var thread_lock
        #   The mutex for protecting the listening_thread
        self.thread_lock = threading.Lock()

        ## @var detected_event
        # An event object to communicate with the scheduler
        self.detected_event: threading.Event = event

        ## @var schedule_buffer
        # A scheduler object to pass the schedule to the scheduler
        self.schedule_buffer = buffer

        ## @var logger
        #  A Logger for recording activities
        self.logger = logger

    def listen(self):
        """! Listen for incoming alerts
        """
        with self.thread_lock:
            if (self.listening_thread is None):
                self.listening_thread = InterruptibleThread(target=self._alert_listener)
                self.listening_thread.start()
            else:
                # already listening
                pass

    def stop_listening(self):
        """! Stop listening for alerts
        """
        # stop the alert handler from listening for new alerts
        with self.thread_lock:
            if (self.listening_thread):
                # kill the listening thread
                self.listening_thread.interrupt()
                self.listening_thread.join()
                self.listening_thread = None
            else:
                # thread is already dead
                pass
    
    @_run_interruptible_thread
    def _alert_listener(self):
        """! Specific alert listener (busy wait, etc.), implemented by child classes
        """
        pass


    def handle_alert(self, data):
        """! Abstract alert handling
        @param data             Any data that may be required for handling as generated by _alert_listener
        """
        pass